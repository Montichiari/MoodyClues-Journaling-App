package com.moodyclues.controller;

import java.time.*;
import java.util.*;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.*;
import org.springframework.web.bind.annotation.*;

import com.moodyclues.model.JournalUser;
import com.moodyclues.model.LinkRequest;
import com.moodyclues.repository.JournalEntryRepository;
import com.moodyclues.repository.LinkRequestRepository;

import jakarta.servlet.http.HttpSession;

@RestController
@RequestMapping("/api/counsellor/dashboard")
public class CounsellorDashboardController {

  @Autowired private JournalEntryRepository journalEntryRepo;
  @Autowired private LinkRequestRepository linkRequestRepo;

  @GetMapping("/window")
  public ResponseEntity<?> getDashboardWindow(
      HttpSession session,
      @RequestParam(required = false) String counsellorId,
      @RequestParam(required = false) Integer days,
      @RequestParam(required = false)
      @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate from,
      @RequestParam(required = false)
      @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate to
  ) {
    // Resolve counsellor id: prefer session, fall back to query param
    String effectiveCounsellorId = (String) session.getAttribute("id");
    if (effectiveCounsellorId == null) effectiveCounsellorId = counsellorId;
    if (effectiveCounsellorId == null || effectiveCounsellorId.isBlank()) {
      return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("No counsellorId provided");
    }

    ZoneId zone = ZoneId.of("Asia/Singapore");
    LocalDate today = (to != null) ? to : LocalDate.now(zone);
    LocalDate startDate = (from != null && to != null)
        ? from
        : today.minusDays((days == null ? 7 : Math.max(1, days)) - 1);

    LocalDateTime startTs = startDate.atStartOfDay();
    LocalDateTime endTs   = today.plusDays(1).atStartOfDay().minusNanos(1);

    // Get approved/linked clients
    List<JournalUser> clients = linkRequestRepo.findApprovedClients(
        effectiveCounsellorId, LinkRequest.Status.APPROVED);

    // shape clients list for the payload (id, firstName)
    List<Map<String, Object>> clientsLite = clients.stream()
        .map(u -> {
          Map<String,Object> m = new LinkedHashMap<>();
          m.put("id", u.getId());
          m.put("firstName", u.getFirstName()); // adjust if your field is different
          return m;
        })
        .collect(Collectors.toList());

    // For each client, gather series
    Map<String, Object> seriesByClient = new LinkedHashMap<>();
    for (JournalUser u : clients) {
      var jd = journalEntryRepo.findDailyAggBetween(u.getId(), startTs, endTs);
      var ec = journalEntryRepo.countEmotionsBetween(u.getId(), startTs, endTs);

      Map<String, Object> perClient = new LinkedHashMap<>();
      perClient.put("journalDaily", jd);
      perClient.put("emotionCounts", ec);   
      seriesByClient.put(u.getId(), perClient);
    }

    // Build payload
    Map<String,Object> window = new LinkedHashMap<>();
    window.put("from", startDate);
    window.put("to", today);

    Map<String,Object> payload = new LinkedHashMap<>();
    payload.put("window", window);
    payload.put("clients", clientsLite);
    payload.put("seriesByClient", seriesByClient);

    return ResponseEntity.ok(payload);
  }
}
